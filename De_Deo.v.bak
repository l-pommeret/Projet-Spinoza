Require Import Coq.Init.Logic.
Require Import Coq.Logic.Classical.

Section SpinozaJarrett.

(* UNIVERS *)
Variable U : Type.  (* L'univers des objets *)

(* OPÉRATEURS MODAUX *)
Variable L : Prop -> Prop.  (* Nécessité logique *)
Variable M : Prop -> Prop.  (* Possibilité *)
Variable N : Prop -> Prop.  (* Nécessité naturelle *)

(* LEXIQUE - défini en premier pour être utilisé dans les axiomes modaux *)
(* Prédicats unaires *)
Variable A_1 : U -> Prop. (* x est un attribut *)
Variable B_1 : U -> Prop. (* x est libre *)
Variable D_1 : U -> Prop. (* x est une instance de désir *)
Variable E_1 : U -> Prop. (* x est éternel *)
Variable F_1 : U -> Prop. (* x est fini *)
Variable G_1 : U -> Prop. (* x est un dieu *)
Variable J_1 : U -> Prop. (* x est une instance d'amour *)
Variable K_1 : U -> Prop. (* x est une idée *)
Variable M_1 : U -> Prop. (* x est un mode *)
Variable N_1 : U -> Prop. (* x est nécessaire *)
Variable S_1 : U -> Prop. (* x est une substance *)
Variable T_1 : U -> Prop. (* x est vrai *)
Variable U_1 : U -> Prop. (* x est un intellect *)
Variable W_1 : U -> Prop. (* x est une volonté *)

(* Prédicats binaires *)
Variable A_2 : U -> U -> Prop. (* x est un attribut de y *) 
Variable C_2 : U -> U -> Prop. (* x est conçu à travers y *) 
Variable I_2 : U -> U -> Prop. (* x est en y *) 
Variable K_2 : U -> U -> Prop. (* x est cause de y *) 
Variable L_2 : U -> U -> Prop. (* x limite y *) 
Variable M_2 : U -> U -> Prop. (* x est un mode de y *) 
Variable O_2 : U -> U -> Prop. (* x est un objet de y *) 
Variable P_2 : U -> U -> Prop. (* x est la puissance de y *) 
Variable R_2 : U -> U -> Prop. (* x a plus de réalité que y *) 
Variable V_2 : U -> U -> Prop. (* x a plus d'attributs que y *) 

(* Prédicats ternaires *)
Variable C_3 : U -> U -> U -> Prop.  (* x est commun à y et à z *)
Variable D_3 : U -> U -> U -> Prop.  (* x est divisible entre y et z *)

(* AXIOMES MODAUX FONDAMENTAUX *)
(* R1: Axiome de nécessité logique implique nécessité naturelle *)
Axiom R1 : forall P:Prop, L(P) -> N(P).

(* R2: Axiome T pour la nécessité naturelle *)
Axiom R2 : forall P:Prop, N(P) -> P.

(* R3: Axiome K pour la nécessité logique *)
Axiom R3 : forall P Q:Prop, L(P -> Q) -> (L(P) -> L(Q)).

(* R4: Axiome S5 - possibilité et nécessité *)
Axiom R4 : forall P:Prop, M(P) -> L(M(P)).

(* R5: Règle de nécessitation *)
Axiom R5 : forall P:Prop, P -> L(P).
(* Note: Cette règle a une restriction importante : P ne doit dépendre d'aucune hypothèse *)

(* R6: Axiome de distributivité pour la nécessité naturelle *)
Axiom R6 : forall P Q:Prop, N(P -> Q) -> (N(P) -> N(Q)).

(* R7: Extraction de l'implication à partir de l'équivalence (pour la nécessité naturelle) *)
Axiom R7 : forall P Q:Prop, N(P <-> Q) -> N(P -> Q).

(* R8: Extraction de l'implication réciproque à partir de l'équivalence (pour la nécessité naturelle) *)
Axiom R8 : forall P Q:Prop, N(P <-> Q) -> N(Q -> P).

(* R9: Axiome de nécessité - une proposition nécessaire est vraie dans tous les mondes possibles *)
Axiom R9 : forall P:Prop, N(P) -> ~M(~P).

(* R10: Axiome de la chaîne causale des modes finis - pour un mode fini non nécessaire, il existe un autre mode fini non nécessaire qui le cause *)
Axiom R10 : forall x:U, F_1 x /\ ~N(exists v:U, v = x) -> 
  exists z:U, z <> x /\ K_2 z x /\ ~N(exists v:U, v = z) /\ F_1 z.

(* DR1: L(P) -> P - Axiome T pour la nécessité logique (dérivé de R1 et R2) *)
Lemma DR1 : forall P:Prop, L(P) -> P.
Proof.
  intros P H.
  apply R2.
  apply R1.
  assumption.
Qed.

(* Règle importante pour l'argument ontologique (utilisée dans P11) *)
(* La formule dans S5: (Mp & L(p -> Lp)) -> Lp *)
Lemma ontological_rule : forall P:Prop,
  M(P) -> L(P -> L(P)) -> L(P).
Proof.
  intros P HMP HLImpl.
  
  (* Application de la logique modale S5 *)
  (* Dans S5, nous avons: M(P) -> L(M(P)) *)
  pose proof (R4 P HMP) as HLMP.
  
  (* Preuve par contradiction *)
  apply NNPP.
  intro HNotLP.
  
  (* Si ~L(P), alors aussi ~P (car P -> L(P) est nécessairement vrai) *)
  assert (HNotP: ~P).
  { 
    intro HP.
    (* Si P est vrai et que (P -> L(P)) est nécessairement vrai, alors L(P) est vrai *)
    (* Mais nous savons que ~L(P), donc ~P *)
    apply HNotLP.
    apply DR1 in HLImpl. (* L(P -> L(P)) -> (P -> L(P)) *)
    apply HLImpl. (* (P -> L(P)) *)
    exact HP. (* P *)
    (* Donc L(P), ce qui contredit ~L(P) *)
  }
  
  (* Mais si ~P, alors ~M(P), ce qui contredit L(M(P)) *)
  assert (HNotMP: ~M(P)).
  { 
    intro HMP2.
    (* De M(P) on déduit que P est possible, donc ne peut pas être impossible *)
    apply HNotP.
    (* Cependant, de L(M(P)) on déduit que M(P) est nécessairement vrai *)
    (* En logique modale S5, si M(P) est nécessairement vrai, alors P est possible dans tous les mondes *)
    (* Donc il existe au moins un monde où P est vrai *)
    (* Comme nous utilisons le système S5, ce monde est accessible depuis le monde actuel *)
    (* Par conséquent, P ne peut pas être impossible, ce qui contredit ~P *)
    (* Cette partie de la preuve nécessite une sémantique des mondes possibles *)
    (* qui n'est pas directement formalisable dans Coq sans axiomes supplémentaires *)
    admit.
  }
  
  (* Contradiction: nous avons à la fois M(P) et ~M(P) *)
  exact (HNotMP HMP).
Admitted.




















Variable K_2 : U -> U -> Prop. (* x est cause de y *) 
Variable L_2 : U -> U -> Prop. (* x limite y *) 
Variable M_2 : U -> U -> Prop. (* x est un mode de y *) 
Variable O_2 : U -> U -> Prop. (* x est un objet de y *) 
Variable P_2 : U -> U -> Prop. (* x est la puissance de y *) 
Variable R_2 : U -> U -> Prop. (* x a plus de réalité que y *) 
Variable V_2 : U -> U -> Prop. (* x a plus d'attributs que y *) 

Variable C_3 : U -> U -> U -> Prop.  (* x est commun à y et à z *)
Variable D_3 : U -> U -> U -> Prop.  (* x est divisible entre y et z *)

(* DÉFINITIONS *)

(* D1 : Causa sui - ce dont l'essence implique l'existence *)
Axiom D1 : forall x:U,
  (K_2 x x /\ ~ exists y:U, y <> x /\ K_2 y x) <-> L(exists y:U, y = x).

(* D2 : Une chose est finie quand elle peut être limitée par une autre de même nature *)
Axiom D2 : forall x:U,
  F_1 x <-> exists y:U, (y <> x /\ L_2 y x /\ forall z:U, A_2 z x <-> A_2 z y).

(* D3 : Une substance est ce qui est en soi et est conçu par soi *)
Axiom D3 : forall x:U, 
  S_1 x <-> (I_2 x x /\ C_2 x x).

(* D4a : Un attribut est ce que l'intellect perçoit de la substance comme constituant son essence *)
Axiom D4a : forall x:U,
  A_1 x <-> exists y:U, (S_1 y /\ I_2 x y /\ C_2 x y /\ I_2 y x /\ C_2 y x).

(* D4b : x est un attribut de y *)
Axiom D4b : forall x y:U,
  A_2 x y <-> (A_1 x /\ C_2 y x).

(* D5a : Un mode est ce qui est dans autre chose et est conçu par elle *)
Axiom D5a : forall x y:U,
  M_2 x y <-> (x <> y /\ I_2 x y /\ C_2 x y).

(* D5b : x est un mode *)
Axiom D5b : forall x:U,
  M_1 x <-> exists y:U, (S_1 y /\ M_2 x y).

(* D6 : Dieu est une substance constituée d'une infinité d'attributs *)
Axiom D6 : forall x:U,
  G_1 x <-> (S_1 x /\ forall y:U, A_1 y -> A_2 y x).

(* D7a : Une chose est libre quand elle n'est cause que d'elle-même *)
Axiom D7a : forall x:U,
  B_1 x <-> (K_2 x x /\ ~ exists y:U, y <> x /\ K_2 y x).

(* D7b : Une chose est nécessaire quand elle est déterminée par autre chose *)
Axiom D7b : forall x:U,
  N_1 x <-> exists y:U, y <> x /\ K_2 y x.

(* D8 : L'éternité est l'existence même en tant que nécessaire *)
Axiom D8 : forall x:U,
  E_1 x <-> L(exists v:U, v = x).

(* AXIOMES DE SPINOZA *)
(* A1 : Tout ce qui est, est soit en soi, soit en autre chose *)
Axiom A1 : forall x:U,
  I_2 x x \/ exists y:U, y <> x /\ I_2 x y.

(* A2 : Ce qui ne peut être conçu par un autre doit être conçu par soi *)
Axiom A2 : forall x:U,
  (~ exists y:U, y <> x /\ C_2 x y) <-> C_2 x x.

(* A3 : D'une cause déterminée suit nécessairement un effet *)
Axiom A3 : forall x y:U,
  K_2 y x -> N((exists v:U, v = y) <-> exists v:U, v = x).

(* A4 : La connaissance de l'effet dépend de la connaissance de la cause *)
Axiom A4 : forall x y:U,
  K_2 x y <-> C_2 y x.

(* A5 : Les choses qui n'ont rien en commun ne peuvent être conçues l'une par l'autre *)
Axiom A5 : forall x y:U,
  (~ exists z:U, C_3 z x y) <-> (~ C_2 x y /\ ~ C_2 y x).

(* A6 : L'idée vraie doit s'accorder avec son objet *)
Axiom A6 : forall x:U,
  K_1 x -> (T_1 x <-> exists y:U, O_2 y x /\ K_2 x y).

(* A7 : Si une chose peut être conçue comme non existante, son essence n'implique pas l'existence *)
Axiom A7 : forall x:U,
  M(~ exists y:U, y = x) <-> ~ L(exists y:U, y = x).

(* AXIOMES SUPPLÉMENTAIRES, découverts par Charles Jarrett *)
(* A8 : Si x est en y alors x est conçu par y *)
Axiom A8 : forall x y:U, I_2 x y -> C_2 x y.

(* A9 : Toute chose a un attribut *)
Axiom A9 : forall x:U, exists y:U, A_2 y x.

(* A10 : Si x est divisible en y et z alors il est possible que x n'existe pas *)
Axiom A10 : forall x y z:U,
  D_3 x y z -> M(~ exists w:U, w = x).
  
(* A11 : Si x est une substance et y limite x alors y est une substance *)
Axiom A11 : forall x y:U,
  S_1 x /\ L_2 y x -> S_1 y.

(* A12 : Si x est un mode de quelque chose alors x est un mode *)
Axiom A12 : forall x:U,
  (exists y:U, M_2 x y) -> M_1 x.

(* A13 : Il est possible qu'un Dieu existe *)
Axiom A13 : M(exists x:U, G_1 x).

(* A14 : x existe nécessairement si et seulement si x n'est pas fini *)
Axiom A14 : forall x:U,
  N(exists y:U, y = x) <-> ~ F_1 x.

(* A15 : Axiome sur le rapport entre existence temporelle et non-existence *)
(* Note: Cette formulation évite d'utiliser la notation temporelle "at t" non définie *)
Axiom A15 : forall x:U,
  ~G_1 x -> (~L(exists y:U, y = x) /\ N(exists y:U, y = x) <-> E_1 x).
  
(* A16 : Si x et y ont un attribut commun, alors ils ont quelque chose en commun *)
Axiom A16 : forall x y:U,
  (exists z:U, A_2 z x /\ A_2 z y) -> (exists z:U, C_3 z x y).
  
(* A17a-d : Axiomes sur les types d'attributs *)
Axiom A17a : forall x:U, U_1 x -> ~A_1 x.
Axiom A17b : forall x:U, W_1 x -> ~A_1 x.
Axiom A17c : forall x:U, D_1 x -> ~A_1 x.
Axiom A17d : forall x:U, J_1 x -> ~A_1 x.
  
(* A18 : Si x et y sont des substances, alors x a plus de réalité que y ssi x a plus d'attributs que y *)
Axiom A18 : forall x y:U,
  (S_1 x /\ S_1 y) -> (R_2 x y <-> V_2 x y).
  
(* A19 : Si x est un attribut de y et est conçu par y et est en y, alors x est la puissance de y *)
Axiom A19 : forall x y:U,
  (((I_2 x y /\ C_2 x y) /\ I_2 y x) /\ C_2 y x) = P_2 x y.

(*PROPOSITIONS*)



(* P1 : Si x est un mode de y et y est une substance, alors x est en y et y est en soi *)
Theorem P1 : forall x y:U, 
  M_2 x y /\ S_1 y -> I_2 x y /\ I_2 y y.
Proof.
  (* On pose nos hypothèses *)
  intros x y [HM HS].

  (* Premièrement, de HS (y est une substance) et D3 (définition de substance), 
     on peut déduire que y est en soi *)
  assert (HIyy: I_2 y y).
  { apply D3 in HS.  (* Par D3 : y substance <-> y en soi et y conçu par soi *)
    destruct HS as [HIyy _]. (* On garde juste y en soi *)
    exact HIyy. 
  }

  (* Deuxièmement, de HM (x est un mode de y) et D5a (définition de mode), 
     on peut déduire que x est en y *)
  assert (HIxy: I_2 x y).
  { apply D5a in HM. (* Par D5a : x mode de y <-> x≠y et x en y et x conçu par y *)
    destruct HM as [_ [HIxy _]]. (* On garde juste x en y *)
    exact HIxy.
  }

  (* Enfin, on combine les deux résultats *)
  split.
  - exact HIxy. (* x est en y *)
  - exact HIyy. (* y est en soi *)
Qed.

Theorem P2 : forall x y:U,
  S_1 x /\ S_1 y /\ x <> y -> ~ exists z:U, C_3 z x y.
Proof.
  (* Introduction des hypothèses *)
  intros x y [HSx [HSy Hxy]].
  
  (* Application de D3 à x *)
  assert (HCx: I_2 x x /\ C_2 x x).
  { apply D3. exact HSx. }
  destruct HCx as [HIxx HCxx].
  
  (* Application de D3 à y *)
  assert (HCy: I_2 y y /\ C_2 y y).
  { apply D3. exact HSy. }
  destruct HCy as [HIyy HCyy].
  
  (* Pour montrer ~C_2 x y *)
  assert (HNoCxy: ~C_2 x y).
  { apply A2 in HCxx.
    intros HC2xy.
    apply HCxx.
    exists y; auto. }
    
  (* Pour montrer ~C_2 y x *)
  assert (HNoCyx: ~C_2 y x).
  { apply A2 in HCyy.
    intros HC2yx.
    apply HCyy.
    exists x; auto. }
    
  (* Conclusion par A5 *)
  apply A5.
  split.
  - exact HNoCxy.
  - exact HNoCyx.
Qed.

(* P3 : Si x et y n'ont rien en commun, alors x ne peut pas être cause de y et y ne peut pas être cause de x *)
Theorem P3 : forall x y:U,
  (~ exists z:U, C_3 z x y) -> ~ K_2 x y /\ ~ K_2 y x.
Proof.
  (* Introduction des hypothèses *)
  intros x y H_no_common.
  
  (* Application de A5 à l'hypothèse : 
     si x,y n'ont rien en commun alors ils ne peuvent être conçus l'un à travers l'autre *)
  apply A5 in H_no_common.
  destruct H_no_common as [H_no_Cxy H_no_Cyx].
  
  (* Nous allons prouver les deux parties de la conjonction *)
  split.
  
  (* Première partie : ~K_2 x y *)
  - intros H_Kxy.
    (* Par A4, si x est cause de y alors y est conçu à travers x *)
    apply A4 in H_Kxy.
    (* Contradiction avec H_no_Cyx *)
    contradiction.
    
  (* Deuxième partie : ~K_2 y x *)
  - intros H_Kyx.
    (* Par A4, si y est cause de x alors x est conçu à travers y *)
    apply A4 in H_Kyx.
    (* Contradiction avec H_no_Cxy *)
    contradiction.
Qed.

(** x neq y -> y neq x *)
Lemma neq_sym : forall x y:U, 
  x <> y -> y <> x.
Proof.
  intros x y H.
  intro Heq.
  apply H.
  symmetry.
  exact Heq.
Qed.

(* x est une substance ssi x est en soi *)
Lemma DP1 : forall x:U,
  S_1 x <-> I_2 x x.
Proof.
  intros. split.
  - intro. apply D3 in H. destruct H. exact H.
  - intro. apply D3. split.
    + assumption.
    + apply A8. assumption.
Qed.

(** DP4: A substance is its own cause *)
Lemma DP4 : forall x:U,
  S_1 x -> K_2 x x.
Proof.
  intros x HS.
  apply A4.
  apply D3 in HS.
  destruct HS as [_ HC].
  exact HC.
Qed.


(** DP5 : Toute chose est soit une substance soit un mode *)
Lemma DP5 : forall x:U,
  S_1 x \/ M_1 x.
Proof.
  intro. pose proof (A1 x). destruct H.
  - left. apply DP1. assumption.
  - right. destruct H as [y [H1 H2]].
    pose proof (A8 _ _ H2). apply A12.
    exists y. apply D5a. split.
    + apply neq_sym. assumption.
    + split; assumption.
Qed.


(** DP6 : Une substance et un mode ne peuvent jamais être la même chose *)
Lemma DP6 : forall x:U,
  ~(S_1 x /\ M_1 x).
Proof.
  intros x [HS HM].
  (* x est un mode donc il existe une substance y dont x est le mode (D5b) *)
  apply D5b in HM. destruct HM as [y [HSy HMxy]].
  (* x est un mode de y donc conçu par y (D5a) *)
  apply D5a in HMxy. destruct HMxy as [Hneq [_ HCxy]].
  (* x est une substance donc conçu par soi (D3) *)
  apply D3 in HS. destruct HS as [_ HCxx].
  (* Par A2, si x est conçu par soi, il ne peut être conçu par autre chose *)
  apply A2 in HCxx.
  apply HCxx.
  exists y.
  split.
  - apply neq_sym in Hneq. exact Hneq.
  - exact HCxy.
Qed.

(* DP7 : Si x est un attribut de y et y est une substance, alors x = y *)
Lemma DP7 : forall x y:U, A_2 x y /\ S_1 y -> x = y.
Proof.
  (* Introduction des hypothèses *)
  intros x y [HA2 HS].
  
  (* De HA2 (x est un attribut de y) et D4b, on obtient que y est conçu à travers x *)
  apply D4b in HA2.
  destruct HA2 as [_ HCyx].
  
  (* De HS (y est une substance) et D3, on obtient que y est conçu par soi *)
  apply D3 in HS.
  destruct HS as [_ HCyy].
  
  (* Par A2, si y est conçu par soi, il ne peut être conçu par autre chose *)
  apply A2 in HCyy.
  
  (* Preuve par l'absurde : supposons x ≠ y *)
  assert (H: x = y).
  { (* Par le tiers exclu, soit x = y soit x ≠ y *)
    apply NNPP. (* Not Not P -> P *)
    intro Hneq.
    (* Si x ≠ y, alors y serait conçu à travers quelque chose d'autre que soi *)
    apply HCyy.
    exists x.
    split.
    - exact Hneq.
    - exact HCyx.
  }
  exact H.
Qed.

(** DPI: Everything is either a substance or a mode, but not both *)
Theorem DPI : forall x:U,
  (S_1 x /\ ~M_1 x) \/ (~S_1 x /\ M_1 x).
Proof.
  intro x. pose proof DP5 x.
  pose proof DP6 x. destruct H; [left | right];
  split; auto; intro; apply H0; auto; split; auto.
Qed.

(** DPII: A substance is its own attribute *)
Theorem DPII : forall x:U,
  S_1 x -> A_2 x x.
Proof.
  intros x HS.
  (* Pour montrer A_2 x x, on utilise D4b *)
  apply D4b. split.
  - (* Montrons que x est un attribut (A_1 x) *)
    apply D4a.
    exists x.
    (* x est une substance (hypothèse HS) *)
    split; [exact HS|].
    (* De HS et D3, on obtient que x est en soi et conçu par soi *)
    apply D3 in HS as [HIxx HCxx].
    repeat split; assumption.
  - (* Montrons que x est conçu à travers x (C_2 x x) *)
    apply D3 in HS.
    destruct HS as [_ HCxx].
    exact HCxx.
Qed.

(** DPIII: Something is a substance if and only if it is self-caused *)
Theorem DPIII : forall x:U,
  S_1 x <-> K_2 x x.
Proof.
  intros. split; intro.
  - (* Si x est une substance, alors x est cause de soi *)
    (* Déjà prouvé par DP4 *)
    apply DP4. auto.
  - (* Si x est cause de soi, alors x est une substance *)
    (* Par A4, si x est cause de y, alors y est conçu à travers x *)
    apply A4 in H. (* Cela donne C_2 x x *)
    
    (* Par A1, tout ce qui est, est soit en soi, soit en autre chose *)
    pose proof (A1 x) as [HIxx | HIxy].
    + (* Si x est en soi (I_2 x x), alors par D3, x est une substance *)
      apply D3. split.
      * exact HIxx.
      * exact H.
    + (* Si x est en autre chose (I_2 x y), alors... *)
      destruct HIxy as [y [Hneq HIxy]].
      (* Par A8, si x est en y alors x est conçu par y *)
      apply A8 in HIxy.
      (* Par A2, si x est conçu par soi, alors il n'est pas conçu par autre chose *)
      assert (HC: ~ exists z : U, z <> x /\ C_2 x z).
      { apply A2. exact H. }
      (* Contradiction: x est conçu par y (y≠x) *)
      destruct HC. exists y. split; assumption.
Qed.

(** P4: Two or more distinct things are distinguished one from the other, either by the 
    difference of the attributes of the substances, or by the difference of their modifications. *)
Theorem P4 : forall x y:U,
  x <> y -> exists z z':U,
  ((A_2 z x /\ A_2 z' y /\ z <> z') \/
   (A_2 z x /\ z = x /\ M_1 y) \/
   (A_2 z' y /\ z' = y /\ M_1 x) \/
   (M_1 x /\ M_1 y)).
Proof.
  intros x y H. 
  pose proof (DPI x) as [H0 | H0].
  - (* x is substance *)
    pose proof (DPI y) as [H1 | H1].
    + (* Both are substances *)
      exists x; exists y.
      left. split.
      * apply DPII. destruct H0. auto.
      * split.
        -- apply DPII. destruct H1. auto.
        -- auto.
    + (* x is substance, y is mode *)
      exists x; exists y.
      right. left. split.
      * apply DPII. destruct H0. auto.
      * split.
        -- reflexivity.
        -- destruct H1. auto.
  - (* x is mode *)
    pose proof (DPI y) as [H1 | H1].
    + (* y is substance, x is mode *)
      exists x; exists y.
      right. right. left. split.
      * apply DPII. destruct H1. auto.
      * split.
        -- reflexivity.
        -- destruct H0. auto.
    + (* Both are modes *)
      exists x; exists y.
      right. right. right.
      destruct H0. destruct H1. split; auto.
Qed.

(* P5: In rerum natura non possunt dari duae, aut plures substantiae ejusdem naturae, sive attributi *)
(* Prémisses: P4, DP6, DP7 ou DP7 seul ou P2, A16 seul *)
Theorem P5 : forall x y:U,
  S_1 x /\ S_1 y /\ x <> y -> ~ exists z:U, (A_2 z x /\ A_2 z y).
Proof.
  (* Introduction des hypothèses *)
  intros x y [HSx [HSy Hneq]].
  
  (* Preuve par contradiction *)
  intro H.
  destruct H as [z H].
  destruct H as [HAzx HAzy].
  
  (* Si z est un attribut de x et de y, alors par DP7, z = x et z = y *)
  assert (Hz_eq_x: z = x).
  { apply DP7. split; assumption. }
  
  assert (Hz_eq_y: z = y).
  { apply DP7. split; assumption. }
  
  (* Par transitivité de l'égalité, x = y *)
  assert (Hx_eq_y: x = y).
  { rewrite <- Hz_eq_x. exact Hz_eq_y. }
  
  (* Contradiction avec l'hypothèse x ≠ y *)
  contradiction.
Qed.

(* P6: Una substantia non potest produci ab alia substantia *)
(* Prémisses: P2, P3 *)
Theorem P6 : forall x y:U,
  S_1 x /\ S_1 y /\ x <> y -> ~(K_2 x y /\ ~K_2 y x).
Proof.
  (* Introduction des hypothèses *)
  intros x y [HSx [HSy Hneq]].
  
  (* Preuve par contradiction *)
  intro H.
  destruct H as [HKxy HNKyx].
  
  (* Par P2, deux substances n'ont rien en commun *)
  assert (HNoCommon: ~ exists z:U, C_3 z x y).
  { apply P2. split; [exact HSx | split; [exact HSy | exact Hneq]]. }
  
  (* Par P3, si deux choses n'ont rien en commun, l'une ne peut pas être cause de l'autre *)
  assert (HNoCauses: ~ K_2 x y /\ ~ K_2 y x).
  { apply P3. assumption. }
  
  (* La contradiction est évidente : HKxy contredit la première partie de HNoCauses *)
  destruct HNoCauses as [HNKxy _].
  contradiction.
Qed.

(* P6c: Corollaire de P6 *)
(* Prémisses: D3, A2, A4 *)
Theorem P6c : forall x:U,
  S_1 x -> ~(exists y:U, y <> x /\ K_2 y x).
Proof.
  (* Introduction des hypothèses *)
  intros x HSx.
  
  (* Preuve par contradiction *)
  intro H.
  destruct H as [y [Hneq HKyx]].
  
  (* Par A4, si y est cause de x, alors x est conçu à travers y *)
  assert (HCxy: C_2 x y).
  { apply A4. exact HKyx. }
  
  (* Par D3, si x est une substance, alors x est conçu par soi *)
  assert (HCxx: C_2 x x).
  { apply D3 in HSx. destruct HSx as [_ HCxx]. exact HCxx. }
  
  (* Par A2, si x est conçu par soi, il ne peut être conçu par une autre chose *)
  assert (H_no_Cxy: ~ exists z : U, z <> x /\ C_2 x z).
  { apply A2. exact HCxx. }
  
  (* Contradiction: x est conçu à travers y (y≠x) *)
  apply H_no_Cxy. exists y. split; assumption.
Qed.

(* P7: Ad naturam substantiae pertinet existere *)
(* Prémisses: D3, P6c, A4, D1 *)
Theorem P7 : forall x:U,
  S_1 x -> L(exists y:U, y = x).
Proof.
  (* Introduction des hypothèses *)
  intros x HSx.
  
  (* Par D3, une substance est ce qui est conçu par soi *)
  assert (HCxx: C_2 x x).
  { apply D3 in HSx. destruct HSx as [_ HCxx]. exact HCxx. }
  
  (* Par A4, si x est conçu par x, alors x est cause de x *)
  assert (HKxx: K_2 x x).
  { apply A4. exact HCxx. }
  
  (* Par P6c, si x est une substance, alors aucune autre chose ne peut être cause de x *)
  assert (HNoExternalCause: ~(exists y:U, y <> x /\ K_2 y x)).
  { apply P6c. exact HSx. }
  
  (* Donc x est sa propre cause et n'a pas de cause externe *)
  assert (H_causa_sui: K_2 x x /\ ~ exists y:U, y <> x /\ K_2 y x).
  { split; assumption. }
  
  (* Par D1, une chose est cause de soi-même ssi son essence implique son existence *)
  apply D1. exact H_causa_sui.
Qed.

(* P8: Omnis substantia est necessario infinita *)
(* Prémisses: D2, A9, A11, P5 *)
Theorem P8 : forall x:U,
  S_1 x -> ~F_1 x.
Proof.
  (* Introduction des hypothèses *)
  intros x HSx.
  
  (* Preuve par contradiction *)
  intro HFx.
  
  (* Par D2, une chose est finie quand elle peut être limitée par une autre de même nature *)
  apply D2 in HFx.
  destruct HFx as [y [Hneq [HLyx HSameAttr]]].
  
  (* Par A11, si x est une substance et y limite x, alors y est une substance *)
  assert (HSy: S_1 y).
  { apply A11 with (x := x). split; assumption. }
  
  (* Par A9, toute chose a au moins un attribut *)
  assert (H_has_attr_x: exists z:U, A_2 z x).
  { apply A9. }
  destruct H_has_attr_x as [z HA2zx].
  
  (* Par HSameAttr, z est aussi un attribut de y *)
  assert (HA2zy: A_2 z y).
  { apply HSameAttr. exact HA2zx. }
  
  (* Par P5, deux substances distinctes ne peuvent pas avoir le même attribut *)
  assert (H_no_common_attr: ~ exists z:U, (A_2 z x /\ A_2 z y)).
  { apply P5. split; [exact HSx | split; [exact HSy | apply neq_sym; exact Hneq]]. }
  
  (* Contradiction: z est un attribut commun à x et y *)
  apply H_no_common_attr. exists z. split; assumption.
Qed.

(* P9: Quo plus realitatis, aut esse unaquaeque res habet, eo plura attributa ipsi competunt *)
(* Prémisses: A18 - Relation entre réalité et attributs *)
Theorem P9 : forall x y:U,
  (S_1 x /\ S_1 y) -> (R_2 x y <-> V_2 x y).
Proof.
  (* Utilisation directe de l'axiome A18 *)
  intros x y H.
  apply A18.
  exact H.
Qed.

(* P10: Unumquodque unius substantiae attributum per se concipi debet *)
(* Prémisses: D3, D4a, A2 *)
Theorem P10 : forall x:U,
  A_1 x -> C_2 x x.
Proof.
  (* Introduction des hypothèses *)
  intros x HA1.
  
  (* Par D4a, si x est un attribut, alors il existe une substance y telle que... *)
  apply D4a in HA1.
  destruct HA1 as [y [HSy [HIxy [HCxy [HIyx HCyx]]]]].
  
  (* Par D3 et HSy, y est conçu par soi *)
  assert (HCyy: C_2 y y).
  { apply D3 in HSy. destruct HSy as [_ HCyy]. exact HCyy. }
  
  (* Par A2, si y est conçu par soi, il ne peut être conçu par autre chose que soi *)
  assert (H_no_Cyz: ~ exists z : U, z <> y /\ C_2 y z).
  { apply A2. exact HCyy. }
  
  (* De HCyx, y est conçu à travers x *)
  (* Si x ≠ y, cela contredirait H_no_Cyz *)
  assert (Hxy_eq: x = y).
  { (* Par le tiers exclu, soit x = y soit x ≠ y *)
    apply NNPP. (* Not Not P -> P *)
    intro Hneq.
    (* Si x ≠ y, alors y serait conçu à travers quelque chose d'autre que soi *)
    apply H_no_Cyz. exists x.
    split; assumption.
  }
  
  (* Si x = y, alors nous pouvons substituer x pour y dans C_2 y y *)
  subst y.
  exact HCyy.
Qed.

(* P11: Deus, sive substantia constans infinitis attributis, quorum unumquodque aeternam, & infinitam essentiam exprimit, necessario existit *)
(* Prémisses: D1, D3, D4a, D4b, D6, A1, A2, A4, A8, A13, A7, P7 *)
Theorem P11 : L(exists x:U, G_1 x).
Proof.
  (* Approche: utiliser l'argument ontologique modal de la règle S5:
     Si (1) P est possible et (2) P implique nécessairement que P est nécessaire,
     alors P est nécessaire *)
  
  (* Étape 1: Montrer que "un Dieu existe" est possible, directement par A13 *)
  pose proof A13 as H_God_possible.
  
  (* Étape 2: Montrer que "un Dieu existe" implique nécessairement que "un Dieu existe" est nécessaire *)
  (* Nous allons démontrer que : L((exists x:U, G_1 x) -> L(exists x:U, G_1 x)) *)
  
  (* D'abord, prouvons que : (exists x:U, G_1 x) -> L(exists x:U, G_1 x) *)
  assert (H_God_to_nec: (exists x:U, G_1 x) -> L(exists x:U, G_1 x)).
  {
    intros H_God_exists.
    destruct H_God_exists as [g H_g_is_God].
    
    (* Par D6, Dieu est une substance *)
    assert (H_g_is_substance: S_1 g).
    { apply D6 in H_g_is_God. destruct H_g_is_God. exact H. }
    
    (* Par P7, toute substance existe nécessairement *)
    assert (H_g_exists_necessarily: L(exists y:U, y = g)).
    { apply P7. exact H_g_is_substance. }
    
    (* Nous devons maintenant transformer L(exists y:U, y = g) en L(exists x:U, G_1 x) *)
    (* Nous savons que g est Dieu, donc ce qui existe nécessairement est un Dieu *)
    
    (* Étape intermédiaire: "g existe" implique "un Dieu existe" *)
    assert (H_g_to_God: (exists y:U, y = g) -> (exists x:U, G_1 x)).
    { 
      intros H_g_exists.
      exists g.
      exact H_g_is_God.
    }
    
    (* Par R5 (règle de nécessitation), nous pouvons transformer cela en nécessité *)
    assert (H_nec_impl: L((exists y:U, y = g) -> (exists x:U, G_1 x))).
    { apply R5. exact H_g_to_God. }
    
    (* Par R3 (axiome K), nous distribuons la nécessité sur l'implication *)
    assert (H_impl_nec: L(exists y:U, y = g) -> L(exists x:U, G_1 x)).
    { apply R3. exact H_nec_impl. }
    
    (* Finalement, nous appliquons l'implication à notre hypothèse *)
    apply H_impl_nec.
    exact H_g_exists_necessarily.
  }
  
  (* Maintenant, appliquons R5 (règle de nécessitation) pour obtenir: 
     L((exists x:U, G_1 x) -> L(exists x:U, G_1 x)) *)
  assert (H_nec_God_to_nec: L((exists x:U, G_1 x) -> L(exists x:U, G_1 x))).
  { apply R5. exact H_God_to_nec. }
  
  (* Étape 3: Appliquer la règle ontologique (Mp & L(p -> Lp)) -> Lp *)
  (* Avec p = (exists x:U, G_1 x) *)
  apply ontological_rule.
  - (* M(exists x:U, G_1 x) - Possibilité de l'existence de Dieu *)
    exact H_God_possible.
  - (* L((exists x:U, G_1 x) -> L(exists x:U, G_1 x)) - Nécessité de l'implication *)
    exact H_nec_God_to_nec.
Qed.

(* P12: Nullum substantiae attributum potest vere concipi, ex quo sequatur, substantiam posse dividi *)
(* Prémisses: A10, P7 *)
Theorem P12 : forall x y z:U,
  S_1 x -> ~D_3 x y z.
Proof.
  (* Introduction des hypothèses *)
  intros x y z HS.
  
  (* Preuve par contradiction *)
  intro HD.
  
  (* Par A10, si x est divisible en y et z, alors il est possible que x n'existe pas *)
  assert (HMnot_exists: M(~ exists w:U, w = x)).
  { apply A10 with (y:=y) (z:=z). exact HD. }
  
  (* Par P7, si x est une substance, alors x existe nécessairement (son essence implique son existence) *)
  assert (HL_exists: L(exists w:U, w = x)).
  { apply P7. exact HS. }
  
  (* Par A7, possibilité de non-existence et nécessité logique sont contradictoires *)
  (* Si p est nécessaire (L(p)), alors ~p ne peut pas être possible (M(~p)) *)
  assert (HNot_M_not_exists: ~M(~ exists w:U, w = x)).
  { 
    (* Utilisation d'A7: M(~p) <-> ~L(p) *)
    (* Si nous avons L(p), alors ~M(~p) par contraposition *)
    (* Prouvons la contraposée de A7 *)
    assert (H_contra_A7: L(exists w:U, w = x) -> ~M(~ exists w:U, w = x)).
    {
      intro HLexists.
      intro HMnotExists.
      (* Par A7, M(~p) <-> ~L(p) *)
      apply A7 in HMnotExists.
      (* Donc ~L(p), mais nous savons L(p), contradiction *)
      contradiction.
    }
    (* Application de la contraposée *)
    apply H_contra_A7.
    exact HL_exists.
  }
  
  (* Contradiction finale: nous avons à la fois M(~p) et ~M(~p) *)
  contradiction.
Qed.

(* P13: Substantia absolute infinita est indivisibilis *)
(* Prémisses: P12 *)
Theorem P13 : forall x y z:U,
  (S_1 x /\ (forall w:U, A_1 w -> A_2 w x)) -> ~D_3 x y z.
Proof.
  (* Introduction des hypothèses *)
  intros x y z [HS HAllAttributes].
  
  (* Application directe de P12 *)
  (* P12 affirme que toute substance est indivisible *)
  (* Puisque x est une substance (hypothèse HS), 
     nous pouvons directement appliquer P12 *)
  apply P12.
  exact HS.
Qed.

(* P14: Praeter Deum nulla dari, neque concipi potest substantia *)
(* Prémisses: P11, D6, A9, D4b, et soit DP7 soit P5 *)
Theorem P14 : exists x:U,
  G_1 x /\ (forall y:U, S_1 y -> y = x).
Proof.
  (* Étape 1: Montrer qu'un Dieu existe *)
  (* Par P11, on sait que Dieu existe nécessairement: L(exists x:U, G_1 x) *)
  (* Par DR1, on peut déduire qu'un Dieu existe effectivement: exists x:U, G_1 x *)
  assert (HGodExists: exists x:U, G_1 x).
  {
    (* Appliquons DR1 (L(P) -> P) à P11 *)
    apply DR1.
    exact P11.
  }
  
  (* Étape 2: Extraire le Dieu g qui existe *)
  destruct HGodExists as [g HGg].
  
  (* Étape 3: Construire notre témoin, g, pour l'existentiel *)
  exists g.
  split.
  - (* Première partie: g est Dieu *)
    exact HGg.
  
  - (* Seconde partie: Toute substance est identique à g *)
    intros y HSy.
    
    (* Par D6, g est une substance possédant tous les attributs *)
    assert (HSg: S_1 g).
    { apply D6 in HGg. destruct HGg. exact H. }
    
    (* Par A9, toute substance possède au moins un attribut *)
    assert (HAttrY: exists a:U, A_2 a y).
    { apply A9. }
    destruct HAttrY as [a HAay].
    
    (* Par D6, g est une substance possédant tous les attributs,
       donc a est aussi un attribut de g *)
    assert (HAag: A_2 a g).
    {
      (* Par D6, g possède tous les attributs *)
      assert (HAllAttr: forall w:U, A_1 w -> A_2 w g).
      { apply D6 in HGg. destruct HGg. exact H0. }
      
      (* De A_2 a y, on déduit A_1 a par D4b *)
      assert (HA1a: A_1 a).
      { apply D4b in HAay. destruct HAay. exact H. }
      
      (* Donc a est un attribut de g *)
      apply HAllAttr.
      exact HA1a.
    }
    
    (* Nous avons maintenant deux substances, g et y, qui partagent le même attribut a *)
    (* Par P5, deux substances ne peuvent pas partager le même attribut, donc g = y *)
    
    (* Préparation pour appliquer P5 par contraposition *)
    (* P5 affirme: S_1 x /\ S_1 y /\ x <> y -> ~ exists z:U, (A_2 z x /\ A_2 z y) *)
    (* Par contraposition: exists z:U, (A_2 z x /\ A_2 z y) -> ~(S_1 x /\ S_1 y /\ x <> y) *)
    (* Ou de manière équivalente: exists z:U, (A_2 z x /\ A_2 z y) /\ S_1 x /\ S_1 y -> x = y *)
    
    assert (HSameSubstance: g = y).
    {
      (* Preuve par contradiction *)
      apply NNPP. (* Not Not P -> P *)
      intro Hneq.
      
      (* Si g ≠ y, alors nous avons deux substances différentes avec le même attribut *)
      (* Ce qui contredit P5 *)
      assert (HContra: ~ exists z:U, (A_2 z g /\ A_2 z y)).
      { apply P5. split; [exact HSg | split; [exact HSy | exact Hneq]]. }
      
      (* Mais nous savons qu'il existe un attribut a tel que A_2 a g /\ A_2 a y *)
      apply HContra.
      exists a.
      split; assumption.
    }
    
    (* Donc y = g *)
    symmetry. exact HSameSubstance.
Qed.

(* P14-A: Version alternative de P14 *)
(* Prémisses: P14, D6 *)
Theorem P14_A : exists x:U,
  forall y:U, G_1 y <-> y = x.
Proof.
  (* Par P14, il existe un Dieu g unique *)
  destruct P14 as [g [HGg HUnique]].
  
  (* Ce Dieu g est notre témoin *)
  exists g.
  
  (* Pour tout y, y est Dieu si et seulement si y = g *)
  intros y.
  split.
  
  (* Première direction: si y est Dieu, alors y = g *)
  - intro HGy.
    (* Par D6, y est une substance *)
    assert (HSy: S_1 y).
    { apply D6 in HGy. destruct HGy. exact H. }
    (* Par HUnique, toute substance est identique à g *)
    apply HUnique.
    exact HSy.
  
  (* Seconde direction: si y = g, alors y est Dieu *)
  - intro Heq.
    (* Si y = g et g est Dieu, alors y est Dieu *)
    rewrite Heq.
    exact HGg.
Qed.

(* P15: Tout ce qui existe est en Dieu et rien ne peut être ni être conçu sans Dieu *)
(* Prémisses: DP5, P14, D3, D5b, D5a *)
Theorem P15 : forall x:U,
  exists g:U, G_1 g /\ I_2 x g /\ C_2 x g.
Proof.
  intro x.
  
  (* Par P14, il existe un Dieu unique g *)
  destruct P14 as [g [HGg HGodUnique]].
  exists g.
  
  (* Montrons que g est Dieu, que x est en g et que x est conçu par g *)
  split; [exact HGg|].
  
  (* Par DP5, tout objet est soit une substance, soit un mode *)
  assert (H_substance_or_mode: S_1 x \/ M_1 x).
  { apply DP5. }
  
  (* Cas 1: x est une substance *)
  destruct H_substance_or_mode as [HSx | HMx].
  {
    (* Si x est une substance, alors par l'unicité de Dieu (P14), x = g *)
    assert (Hxg: x = g).
    { apply HGodUnique. exact HSx. }
    
    (* Par D3, une substance est en soi et conçue par soi *)
    assert (H_in_and_conceived: I_2 x x /\ C_2 x x).
    { apply D3. exact HSx. }
    
    (* Puisque x = g, I_2 x g <-> I_2 x x et C_2 x g <-> C_2 x x *)
    split.
    - (* x est en g (car x = g et une substance est en soi) *)
      destruct H_in_and_conceived as [HIxx _].
      (* Nous devons prouver I_2 x g, mais nous avons I_2 x x et x = g *)
      assert (I_2x_eq: I_2 x x -> I_2 x g).
      { intro H. rewrite <- Hxg. exact H. }
      apply I_2x_eq. exact HIxx.
    - (* x est conçu par g (car x = g et une substance est conçue par soi) *)
      destruct H_in_and_conceived as [_ HCxx].
      (* Nous devons prouver C_2 x g, mais nous avons C_2 x x et x = g *)
      assert (C_2x_eq: C_2 x x -> C_2 x g).
      { intro H. rewrite <- Hxg. exact H. }
      apply C_2x_eq. exact HCxx.
  }
  
  (* Cas 2: x est un mode *)
  {
    (* Par D5b, si x est un mode, alors il existe une substance y dont x est le mode *)
    apply D5b in HMx.
    destruct HMx as [y [HSy HMxy]].
    
    (* Par l'unicité de Dieu (P14), y = g *)
    assert (Hyg: y = g).
    { apply HGodUnique. exact HSy. }
    
    (* Substituer g pour y dans M_2 x y *)
    rewrite Hyg in HMxy.
    
    (* Par D5a, si x est un mode de g, alors x est en g et conçu par g *)
    apply D5a in HMxy.
    destruct HMxy as [_ [HIxg HCxg]].
    split; assumption.
  }
Qed.


(* P16: Dieu est cause de toutes choses *)
(* Prémisses: P15, A4 *)
Theorem P16 : forall x:U,
  exists g:U, G_1 g /\ K_2 g x.
Proof.
  intro x.
  
  (* Par P15, tout ce qui existe est en Dieu et conçu par Dieu *)
  pose proof (P15 x) as [g [HGg [HIxg HCxg]]].
  
  (* Notre témoin est g (Dieu) *)
  exists g.
  
  (* Première partie: g est Dieu *)
  split; [exact HGg|].
  
  (* Seconde partie: g est cause de x *)
  (* Par A4, si x est conçu par g, alors g est cause de x *)
  apply A4.
  exact HCxg.
Qed.

(* P17: Dieu agit par les seules lois de sa nature *)
(* Prémisses: P14, P15, P16, D7a *)
Theorem P17 : exists g:U,
  G_1 g /\ ~(exists x:U, ~I_2 x g /\ K_2 x g) /\ (forall x:U, K_2 g x).
Proof.
  (* Par P14, il existe un Dieu unique g *)
  destruct P14 as [g [HGg HGodUnique]].
  exists g.
  
  (* Nous devons prouver 3 choses:
     1. g est Dieu
     2. g n'est déterminé à agir par aucune cause externe
     3. g est cause de toutes choses *)
  split; [exact HGg|].
  
  (* Montrons que g n'est déterminé à agir par aucune cause externe *)
  split.
  {
    (* Preuve par contradiction *)
    intro HExternal.
    destruct HExternal as [x [HNotInG HCauseG]].
    
    (* Par D6, g est une substance *)
    assert (HSg: S_1 g).
    { apply D6 in HGg. destruct HGg. exact H. }
    
    (* Par P6c, aucune chose distincte ne peut être cause d'une substance *)
    assert (HNoCause: ~(exists y:U, y <> g /\ K_2 y g)).
    { apply P6c. exact HSg. }
    
    (* Pour établir la contradiction, montrons que x ≠ g *)
    assert (Hxg: x <> g).
    {
      (* Preuve par contradiction *)
      intro Heq.
      (* Si x = g, alors "x n'est pas en g" signifierait "g n'est pas en g" *)
      rewrite Heq in HNotInG.
      (* Mais par D3, une substance est en soi *)
      assert (HIgg: I_2 g g).
      { apply D3 in HSg. destruct HSg. exact H. }
      (* Contradiction avec HNotInG *)
      contradiction.
    }
    
    (* Maintenant nous avons x ≠ g et K_2 x g, ce qui contredit HNoCause *)
    apply HNoCause.
    exists x.
    split; assumption.
  }
  
  (* Montrons que g est cause de toutes choses - conséquence directe de P16 *)
  intro x.
  assert (HGodCause: exists h:U, G_1 h /\ K_2 h x).
  { apply P16. }
  destruct HGodCause as [h [HGh HKhx]].
  
  (* Par P14_A, h = g car h est Dieu et g est le seul Dieu *)
  assert (Hhg: h = g).
  {
    destruct P14_A as [k HP14A].
    assert (Hhk: h = k).
    { apply HP14A. exact HGh. }
    assert (Hgk: g = k).
    { apply HP14A. exact HGg. }
    rewrite Hhk.
    symmetry.
    exact Hgk.
  }
  
  (* Donc g est cause de x *)
  rewrite <- Hhg.
  exact HKhx.
Qed.

(* P17c2: Dieu seul est cause libre *)
(* Prémisses: P17, D7a, P14 *)
Theorem P17c2 : exists g:U,
  G_1 g /\ B_1 g /\ (forall x:U, B_1 x -> x = g).
Proof.
  (* Par P17, il existe un Dieu g qui est cause de toutes choses et n'est déterminé par aucune cause externe *)
  destruct P17 as [g [HGg [HNoExternalCause HAllCauses]]].
  exists g.
  
  (* Montrons les trois parties du théorème:
     1. g est Dieu
     2. g est libre
     3. Seul g est libre (toute cause libre est identique à g) *)
  
  (* Première partie: g est Dieu *)
  split; [exact HGg|].
  
  (* Deuxième partie: g est libre *)
  split.
  {
    (* Par D7a, une chose est libre ssi elle est cause que d'elle-même *)
    apply D7a.
    
    (* Par DPIII, une substance est cause de soi-même *)
    assert (HSg: S_1 g).
    { apply D6 in HGg. destruct HGg. exact H. }
    
    assert (HKgg: K_2 g g).
    { apply DPIII. exact HSg. }
    
    (* Par HNoExternalCause, g n'est déterminé à agir par aucune cause externe *)
    (* Donc g est sa propre cause et n'a pas de cause externe *)
    split.
    - (* g est cause de soi *)
      exact HKgg.
    - (* g n'a pas de cause externe *)
      (* Preuve par contradiction *)
      intro HExternalCause.
      destruct HExternalCause as [y [Hyg HKyg]].
      
      (* Si y est cause de g, alors par P15, y est en g *)
      pose proof (P15 y) as [h [HGh [HIyh HCyh]]].
      
      (* Par P14_A, h = g car h est Dieu et g est le seul Dieu *)
      assert (Hhg: h = g).
      {
        destruct P14_A as [k HP14A].
        assert (Hhk: h = k).
        { apply HP14A. exact HGh. }
        assert (Hgk: g = k).
        { apply HP14A. exact HGg. }
        rewrite Hhk.
        symmetry.
        exact Hgk.
      }
      rewrite Hhg in HIyh.
      
      (* Nous avons donc y en g (HIyg) et y cause de g (HKyg) *)
      (* Mais par HNoExternalCause, il n'existe pas de x tel que ~I_2 x g /\ K_2 x g *)
      (* Donc ~(~I_2 y g /\ K_2 y g), ce qui est logiquement équivalent à I_2 y g \/ ~K_2 y g *)
      (* Puisque nous avons I_2 y g, il n'y a pas de contradiction *)
      (* Pour obtenir une contradiction, montrons que y ≠ g *)
      assert (Hyg': y <> g).
      {
        intro Heq.
        (* Si y = g, nous n'aurions pas une cause externe *)
        rewrite Heq in Hyg.
        contradiction.
      }
      
      (* Par P6c, aucune chose distincte ne peut être cause d'une substance *)
      assert (HNoCause: ~(exists z:U, z <> g /\ K_2 z g)).
      { apply P6c. exact HSg. }
      
      (* Maintenant nous avons y ≠ g et K_2 y g, ce qui contredit HNoCause *)
      apply HNoCause.
      exists y.
      split; assumption.
  }
  
  (* Troisième partie: toute cause libre est identique à g *)
  intros x HBx.
  
  (* Par D7a, si x est libre, alors x est cause de soi-même et n'a pas de cause externe *)
  apply D7a in HBx.
  destruct HBx as [HKxx HNoExternalX].
  
  (* Par HKxx et DPIII, x est une substance *)
  assert (HSx: S_1 x).
  { apply DPIII. exact HKxx. }
  
  (* Par P14, toute substance est identique à g *)
  destruct P14 as [h [HGh HGodUnique]].
  
  (* Nous devons montrer que h = g, puis que x = h, et donc x = g *)
  assert (Hhg: h = g).
  {
    destruct P14_A as [k HP14A].
    assert (Hhk: h = k).
    { apply HP14A. exact HGh. }
    assert (Hgk: g = k).
    { apply HP14A. exact HGg. }
    rewrite Hhk.
    symmetry.
    exact Hgk.
  }
  
  rewrite Hhg in HGodUnique.
  apply HGodUnique.
  exact HSx.
Qed.

(* P18: Dieu est cause immanente de toutes choses *)
(* Prémisses: P15, P16 *)
Theorem P18 : exists g:U,
  G_1 g /\ (forall x:U, I_2 x g <-> K_2 g x).
Proof.
  (* Par P16, il existe un Dieu g qui est cause de toutes choses *)
  (* Choisissons n'importe quel x, pour démontrer l'existence de Dieu *)
  destruct P14 as [g [HGg _]].
  exists g.
  
  (* Montrons deux choses:
     1. g est Dieu
     2. Pour tout x, x est en g si et seulement si g est cause de x *)
  split; [exact HGg|].
  
  (* Pour tout objet x *)
  intro x.
  split.
  
  (* Première direction: si x est en g, alors g est cause de x *)
  - intro HIxg.
    (* Par A8, si x est en g, alors x est conçu par g *)
    assert (HCxg: C_2 x g).
    { apply A8. exact HIxg. }
    (* Par A4, si x est conçu par g, alors g est cause de x *)
    apply A4. exact HCxg.
  
  (* Seconde direction: si g est cause de x, alors x est en g *)
  - intro HKgx.
    (* Par P15, tout ce qui existe est en Dieu et conçu par Dieu *)
    destruct (P15 x) as [h [HGh [HIxh _]]].
    
    (* Puisque g et h sont tous deux Dieu, et par P14 il n'existe qu'un seul Dieu,
       g et h doivent être identiques *)
    assert (Hgh: g = h).
    { (* Par P14_A, il existe un unique Dieu *)
      destruct P14_A as [k HP14A].
      (* g est Dieu donc g = k *)
      assert (Hgk: g = k).
      { apply HP14A. exact HGg. }
      (* h est Dieu donc h = k *)
      assert (Hhk: h = k).
      { apply HP14A. exact HGh. }
      (* Par transitivité, g = h *)
      rewrite Hgk. symmetry. exact Hhk.
    }
    
    (* Substituons g pour h dans HIxh *)
    rewrite <- Hgh in HIxh.
    exact HIxh.
Qed.

(* P19: Dieu et tous ses attributs sont éternels *)
(* Prémisses: D8, P14, P14-A, D4b, P10, DP4 *)
Theorem P19 : exists g:U,
  G_1 g /\ E_1 g /\ (forall x:U, A_2 x g -> E_1 x).
Proof.
  (* Par P14, il existe un Dieu g unique *)
  destruct P14 as [g [HGg _]].
  exists g.
  
  (* Montrons trois choses:
     1. g est Dieu
     2. g est éternel
     3. Tous les attributs de g sont éternels *)
  
  (* Première partie: g est Dieu *)
  split; [exact HGg|].
  
  (* Deuxième partie: g est éternel *)
  split.
  {
    (* Par D6, g est une substance *)
    assert (HSg: S_1 g).
    { apply D6 in HGg. destruct HGg. exact H. }
    
    (* Par P7, si x est une substance, alors son essence implique son existence,
       i.e., il existe nécessairement *)
    assert (HNecExist: L(exists y:U, y = g)).
    { apply P7. exact HSg. }
    
    (* Par D8, l'éternité est l'existence même en tant que nécessaire *)
    apply D8. exact HNecExist.
  }
  
  (* Troisième partie: Tous les attributs de g sont éternels *)
  intros x HA2xg.
  
  (* Par D4b, si x est un attribut de g, alors x est un attribut et g est conçu à travers x *)
  apply D4b in HA2xg.
  destruct HA2xg as [HA1x HCgx].
  
  (* Par P10, si x est un attribut, alors x est conçu par soi *)
  assert (HCxx: C_2 x x).
  { apply P10. exact HA1x. }
  
  (* Par DP7, si x est un attribut de g et g est une substance, alors x = g *)
  (* Commençons par montrer que g est une substance *)
  assert (HSg: S_1 g).
  { apply D6 in HGg. destruct HGg. exact H. }
  
  (* Maintenant appliquons DP7 *)
  assert (Hxg: x = g).
  { apply DP7. split; [apply D4b; split; assumption | exact HSg]. }
  
  (* Remplaçons x par g *)
  rewrite Hxg.
  
  (* Nous avons déjà montré que g est éternel *)
  assert (HEg: E_1 g).
  { apply D8. apply P7. exact HSg. }
  
  exact HEg.
Qed.

(* P20: L'existence et l'essence de Dieu sont une seule et même chose *)
(* Prémisses: D4b, P10, DP4, P14, P14-A *)
Theorem P20 : forall x:U,
  exists g:U, G_1 g /\ (A_2 x g -> x = g).
Proof.
  intro x.
  
  (* Par P14, il existe un Dieu unique g *)
  destruct P14 as [g [HGg HUnique]].
  exists g.
  
  (* Montrons deux choses:
     1. g est Dieu
     2. Si x est un attribut de g, alors x = g *)
  
  (* Première partie: g est Dieu *)
  split; [exact HGg|].
  
  (* Deuxième partie: Si x est un attribut de g, alors x = g *)
  intro HA2xg.
  
  (* Par D6, g est une substance *)
  assert (HSg: S_1 g).
  { apply D6 in HGg. destruct HGg. exact H. }
  
  (* Par DP7, si x est un attribut de g et g est une substance, alors x = g *)
  apply DP7. split; assumption.
Qed.

(* P21: Tout ce qui suit de l'essence absolue d'un attribut de Dieu existe nécessairement et infiniment *)
(* Prémisses: P19, D8, A3, A14, R1, R6, R7, P20, DP7 *)
Theorem P21 : forall x:U,
  (exists g y:U, G_1 g /\ A_2 y g /\ x <> g /\ K_2 y x /\ ~(exists z:U, z <> y /\ K_2 z x)) ->
  (N(exists v:U, v = x) /\ ~F_1 x).
Proof.
  intros x H.
  destruct H as [g [y [HGg [HA2yg [Hxg [HKyx HNoOtherCause]]]]]].
  
  (* Par D6, si g est Dieu, alors g est une substance *)
  assert (HSg: S_1 g).
  { apply D6 in HGg. destruct HGg. exact H. }
  
  (* Par DP7, si y est un attribut de g et g est une substance, alors y = g *)
  assert (Hyg: y = g).
  { apply DP7. split; assumption. }
  
  (* Remplaçons y par g dans HKyx *)
  rewrite Hyg in HKyx.
  (* Nous avons maintenant: HKyx : K_2 g x *)
  
  (* Par P19, g est éternel *)
  assert (HEg: E_1 g).
  { destruct P19 as [h [HGh [HEh _]]].
    (* Puisque g et h sont tous deux Dieu, g = h *)
    assert (Hgh: g = h).
    { destruct P14_A as [k HP14A].
      assert (Hgk: g = k).
      { apply HP14A. exact HGg. }
      assert (Hhk: h = k).
      { apply HP14A. exact HGh. }
      rewrite Hgk. symmetry. exact Hhk.
    }
    rewrite Hgh. exact HEh.
  }
  
  (* Par D8, g existe nécessairement (logiquement) *)
  assert (HLg: L(exists v:U, v = g)).
  { apply D8. exact HEg. }
  
  (* Par R1, nécessité logique implique nécessité naturelle *)
  assert (HNg: N(exists v:U, v = g)).
  { apply R1. exact HLg. }
  
  (* Par A3, d'une cause déterminée suit nécessairement un effet *)
  assert (HNec: N((exists v:U, v = g) <-> exists v:U, v = x)).
  { apply A3. exact HKyx. }
  
  (* Démontrons maintenant les deux parties du résultat *)
  split.
  
  - (* 1. x existe nécessairement *)
    (* Utilisons HNec pour extraire la partie gauche de la double implication *)
    assert (HNecImpl1: N((exists v:U, v = g) -> (exists v:U, v = x))).
    {
      (* Utilisons R7 pour extraire l'implication à partir de l'équivalence *)
      apply R7. exact HNec.
    }
    
    (* Appliquons R6 pour distribuer N sur l'implication *)
    (* R6: N(P -> Q) -> (N(P) -> N(Q)) *)
    assert (HNecDist: N(exists v:U, v = g) -> N(exists v:U, v = x)).
    { apply R6. exact HNecImpl1. }
    
    (* Appliquons HNecDist à HNg pour obtenir N(exists v:U, v = x) *)
    apply HNecDist. exact HNg.
    
  - (* 2. x n'est pas fini *)
    (* Par A14, existence nécessaire implique non-finitude *)
    (* A14 : N(exists y:U, y = x) <-> ~F_1 x *)
    apply A14.
    
    (* Utilisons le résultat de la première partie *)
    (* Nous avons déjà construit la chaîne d'arguments ci-dessus *)
    assert (HNecImpl1: N((exists v:U, v = g) -> (exists v:U, v = x))).
    { apply R7. exact HNec. }
    
    assert (HNecDist: N(exists v:U, v = g) -> N(exists v:U, v = x)).
    { apply R6. exact HNecImpl1. }
    
    apply HNecDist. exact HNg.
Qed.

(* P22: Tout ce qui suit d'un attribut de Dieu en tant que modifié est éternel et infini *)
(* Prémisses: DP6, P14, P14-A, D1, P19, D8, A3, A14, R1, R6, R7 *)
Theorem P22 : forall x:U,
  (exists g y y':U, G_1 g /\ A_2 y g /\ M_1 y' /\ ~F_1 y' /\ N(exists v:U, v = y') /\ 
  K_2 y x /\ K_2 y' x /\ ~(exists z:U, z <> y /\ z <> y' /\ K_2 z x)) ->
  (N(exists v:U, v = x) /\ ~F_1 x).
Proof.
  intros x H.
  destruct H as [g [y [y' [HGg [HA2yg [HM1y' [HNFy' [HNy' [HKyx [HKy'x HNoOtherCause]]]]]]]]]].
  
  (* Par D6, si g est Dieu, alors g est une substance *)
  assert (HSg: S_1 g).
  { apply D6 in HGg. destruct HGg. exact H. }
  
  (* Par DP7, si y est un attribut de g et g est une substance, alors y = g *)
  assert (Hyg: y = g).
  { apply DP7. split; assumption. }
  
  (* Remplaçons y par g dans HKyx *)
  rewrite Hyg in HKyx.
  (* Nous avons maintenant: HKyx : K_2 g x et HKy'x : K_2 y' x *)
  
  (* La stratégie est de montrer que y' est un mode infini et nécessaire, et qu'il
     existe nécessairement. De ce fait, par A3, x existe aussi nécessairement. *)
  
  (* Par A3, d'une cause déterminée (y') suit nécessairement un effet (x) *)
  assert (HNec_y'_x: N((exists v:U, v = y') <-> exists v:U, v = x)).
  { apply A3. exact HKy'x. }
  
  (* Démontrons maintenant les deux parties du résultat *)
  split.
  
  - (* 1. x existe nécessairement *)
    (* Utilisons HNec_y'_x pour extraire la partie gauche de la double implication *)
    assert (HNecImpl1: N((exists v:U, v = y') -> (exists v:U, v = x))).
    {
      (* Utilisons R7 pour extraire l'implication à partir de l'équivalence *)
      apply R7. exact HNec_y'_x.
    }
    
    (* Appliquons R6 pour distribuer N sur l'implication *)
    (* R6: N(P -> Q) -> (N(P) -> N(Q)) *)
    assert (HNecDist: N(exists v:U, v = y') -> N(exists v:U, v = x)).
    { apply R6. exact HNecImpl1. }
    
    (* Appliquons HNecDist à HNy' pour obtenir N(exists v:U, v = x) *)
    apply HNecDist. exact HNy'.
    
  - (* 2. x n'est pas fini *)
    (* Par A14, existence nécessaire implique non-finitude *)
    (* A14 : N(exists y:U, y = x) <-> ~F_1 x *)
    apply A14.
    
    (* Utilisons le résultat de la première partie *)
    assert (HNecImpl1: N((exists v:U, v = y') -> (exists v:U, v = x))).
    { apply R7. exact HNec_y'_x. }
    
    assert (HNecDist: N(exists v:U, v = y') -> N(exists v:U, v = x)).
    { apply R6. exact HNecImpl1. }
    
    apply HNecDist. exact HNy'.
Qed.

(* P23: Tout mode qui existe nécessairement et infiniment découle d'un attribut de Dieu *)
(* Prémisses: P14, A9, P19, D8 *)
Theorem P23 : forall x:U,
  N(exists v:U, v = x) -> 
  (exists g y:U, G_1 g /\ A_2 y g /\ N((exists v:U, v = y) -> (exists v:U, v = x))).
Proof.
  intros x HNx.
  
  (* Par P14, il existe un Dieu unique g *)
  destruct P14 as [g [HGg HGodUnique]].
  
  (* Par A9, tout objet a au moins un attribut *)
  assert (HAttrG: exists y:U, A_2 y g).
  { apply A9. }
  destruct HAttrG as [y HA2yg].
  
  (* Notre témoin est (g, y) *)
  exists g, y.
  
  (* Montrons trois choses: 
     1. g est Dieu
     2. y est un attribut de g
     3. y est lié causalement à x *)
  
  (* Première partie: g est Dieu *)
  split. { exact HGg. }
  
  (* Deuxième partie: y est un attribut de g *)
  split. { exact HA2yg. }
  
  (* Troisième partie: Montrer que y est causalement lié à x *)
  
  (* Puisque g est Dieu, c'est une substance *)
  assert (HSg: S_1 g).
  { apply D6 in HGg. destruct HGg. exact H. }
  
  (* Par DP7, si y est un attribut de g et g est une substance, alors y = g *)
  assert (Hyg: y = g).
  { apply DP7. split; [exact HA2yg | exact HSg]. }
  
  (* Par P15, tout ce qui existe est en Dieu et conçu par Dieu *)
  assert (HIxg: I_2 x g /\ C_2 x g).
  {
    pose proof (P15 x) as [h [HGh [HIxh HCxh]]].
    
    (* g = h car ils sont tous deux Dieu, et Dieu est unique par P14_A *)
    assert (Hgh: g = h).
    {
      destruct P14_A as [k HP14A].
      assert (Hgk: g = k). { apply HP14A. exact HGg. }
      assert (Hhk: h = k). { apply HP14A. exact HGh. }
      rewrite Hgk. symmetry. exact Hhk.
    }
    
    (* Remplaçons h par g *)
    rewrite <- Hgh in HIxh.
    rewrite <- Hgh in HCxh.
    split; assumption.
  }
  
  (* Par A4, si x est conçu par g, alors g est cause de x *)
  assert (HKgx: K_2 g x).
  { apply A4. destruct HIxg as [_ HCxg]. exact HCxg. }
  
  (* Puisque y = g, nous avons aussi K_2 y x *)
  assert (HKyx: K_2 y x).
  { rewrite Hyg. exact HKgx. }
  
  (* Par A3, d'une cause déterminée suit nécessairement un effet *)
  assert (HNyx: N((exists v:U, v = y) <-> exists v:U, v = x)).
  { apply A3. exact HKyx. }
  
  (* De cette équivalence nécessaire, nous pouvons extraire l'implication avec R7 *)
  assert (HNyimpx: N((exists v:U, v = y) -> (exists v:U, v = x))).
  { apply R7. exact HNyx. }
  
  (* C'est exactement ce que nous voulions montrer *)
  exact HNyimpx.
Qed.

(* P24: L'essence des choses produites par Dieu n'implique pas l'existence *)
(* Prémisses: D1 *)
Theorem P24 : forall x:U,
  (exists g:U, G_1 g /\ x <> g /\ K_2 g x) -> ~L(exists v:U, v = x).
Proof.
  intros x H.
  destruct H as [g [HGg [Hneq HKgx]]].
  
  (* Preuve par contradiction *)
  intro HLx.
  
  (* Si l'essence de x implique son existence (HLx), alors par D1,
     x est cause de soi-même et n'a pas de cause externe *)
  assert (HCausaSui: K_2 x x /\ ~ exists y:U, y <> x /\ K_2 y x).
  { apply D1. exact HLx. }
  
  (* Mais nous savons que g est une cause de x et g ≠ x *)
  destruct HCausaSui as [_ HNoExternalCause].
  
  (* Cela contredit directement le fait que g est une cause externe de x *)
  apply HNoExternalCause.
  exists g.
  split.
  - (* Nous devons montrer g <> x, mais nous avons x <> g *)
    (* Utilisons la symétrie de l'inégalité *)
    apply neq_sym. exact Hneq.
  - exact HKgx.
Qed.

(* P25: Dieu est cause efficiente de l'essence et de l'existence des choses *)
(* Prémisses: P15, A4 *)
Theorem P25 : forall x:U,
  exists g:U, G_1 g /\ K_2 g x.
Proof.
  intro x.
  
  (* Par P15, tout ce qui existe est en Dieu et conçu par Dieu *)
  destruct (P15 x) as [g [HGg [HIxg HCxg]]].
  
  (* Le témoin est g, le Dieu dont nous venons d'établir l'existence *)
  exists g.
  
  (* Montrons deux choses:
     1. g est Dieu
     2. g est cause de x *)
     
  (* Première partie: g est Dieu *)
  split. { exact HGg. }
  
  (* Deuxième partie: g est cause de x *)
  (* Par A4, si x est conçu par g, alors g est cause de x *)
  apply A4. exact HCxg.
Qed.

(* P26: Une chose déterminée à produire un effet a été déterminée par Dieu *)
(* Prémisses: P16 *)
Theorem P26 : forall x y:U,
  (exists z z':U, M_2 y z /\ M_2 z' z /\ K_2 x y) -> 
  (exists g:U, G_1 g /\ K_2 g y).
Proof.
  intros x y H.
  
  (* P26 est une conséquence directe de P16 *)
  (* P16 établit que Dieu est cause de toutes choses *)
  (* Donc il existe un Dieu g qui est cause de y *)
  
  (* Appliquons P16 directement à y *)
  apply P16.
Qed.

(* P27: Une chose déterminée par Dieu ne peut se rendre indéterminée *)
(* Prémisses: P14-A, A3 *)
Theorem P27 : forall x:U,
  (exists g:U, G_1 g /\ K_2 g x /\ ~(exists z:U, z <> g /\ K_2 z x)) -> 
  N(exists v:U, v = x).
Proof.
  intros x H.
  destruct H as [g [HGg [HKgx HNoOtherCause]]].
  
  (* Par P14-A, il existe un Dieu unique *)
  destruct P14_A as [h HP14A].
  
  (* g = h car g est Dieu et h est le Dieu unique *)
  assert (Hgh: g = h).
  { apply HP14A. exact HGg. }
  
  (* Par P19, Dieu est éternel *)
  assert (HEg: E_1 g).
  { 
    destruct P19 as [k [HGk [HEk _]]].
    (* g = k car g et k sont tous deux Dieu, et Dieu est unique *)
    assert (Hgk: g = k).
    { 
      (* Par HP14A, y est Dieu si et seulement si y = h *)
      (* On a déjà prouvé que g = h *)
      assert (Hkh: k = h). { apply HP14A. exact HGk. }
      
      (* Par transitivité, g = k *)
      rewrite Hgh. symmetry. exact Hkh.
    }
    rewrite Hgk. exact HEk.
  }
  
  (* Par D8, l'éternité est l'existence nécessaire (logique) *)
  assert (HLg: L(exists v:U, v = g)).
  { apply D8. exact HEg. }
  
  (* Par R1, la nécessité logique implique la nécessité naturelle *)
  assert (HNg: N(exists v:U, v = g)).
  { apply R1. exact HLg. }
  
  (* Par A3, d'une cause déterminée suit nécessairement un effet *)
  assert (HNgx: N((exists v:U, v = g) <-> exists v:U, v = x)).
  { apply A3. exact HKgx. }
  
  (* Utilisons R7 pour extraire l'implication de l'équivalence *)
  assert (HNgTox: N((exists v:U, v = g) -> (exists v:U, v = x))).
  { apply R7. exact HNgx. }
  
  (* Utilisons R6 pour distribuer N sur l'implication *)
  assert (HNDist: N(exists v:U, v = g) -> N(exists v:U, v = x)).
  { apply R6. exact HNgTox. }
  
  (* Appliquons HNDist à HNg pour obtenir la nécessité de x *)
  apply HNDist. exact HNg.
Qed.

(* P28: Tout mode fini est déterminé à exister par un autre mode fini *)
(* Prémisses: P14-A, P16, A8, A4, A14, A3, R10, DP4, P8 *)
Theorem P28 : forall x:U,
  (F_1 x /\ ~N(exists v:U, v = x)) -> 
  (exists g:U, G_1 g /\ K_2 g x /\ (forall y:U, I_2 x y -> K_2 y x) /\ 
   (exists z:U, z <> x /\ K_2 z x /\ ~N(exists v:U, v = z) /\ F_1 z)).
Proof.
  intros x [HFx HNotNx].
  
  (* Par P16, pour tout objet, il existe un Dieu qui en est la cause *)
  destruct (P16 x) as [g [HGg HKgx]].
  
  (* g est notre premier témoin *)
  exists g.
  
  (* 1. g est Dieu *)
  split. { exact HGg. }
  
  (* 2. g est cause de x *)
  split. { exact HKgx. }
  
  (* 3. Tout ce en quoi x est, est cause de x *)
  split.
  { 
    intros y HIxy.
    (* Par A8, si x est en y, alors x est conçu par y *)
    assert (HCxy: C_2 x y). { apply A8. exact HIxy. }
    (* Par A4, si x est conçu par y, alors y est cause de x *)
    apply A4. exact HCxy.
  }
  
  (* 4. Il existe un mode fini z qui est cause de x *)
  
  (* Montrons d'abord que x est un mode (et non une substance) *)
  assert (HMx: M_1 x).
  { 
    destruct (DP5 x) as [HSx | HMx].
    - (* Si x est une substance, alors x est infini (P8) *)
      assert (HNotFx: ~F_1 x). { apply P8. exact HSx. }
      (* Contradiction avec notre hypothèse que x est fini *)
      contradiction.
    - exact HMx.
  }
  
  (* Par R10, si x est un mode fini non nécessaire, alors il existe un autre mode fini 
     non nécessaire z qui est cause de x *)
  apply R10. split; assumption.
Qed.

(* P29: Rien n'est contingent dans la nature *)
(* Prémisses: P14-A, P16, D7b *)
Theorem P29 : exists g:U,
  G_1 g /\ L(exists x:U, x = g) /\ (forall x:U, x <> g -> N_1 x).
Admitted.

(* P30: L'entendement doit comprendre les attributs et affections de Dieu *)
(* Prémisses: DP5, A9, D4b, D3, A2 *)
Theorem P30 : forall x y:U,
  (A_1 x /\ T_1 x /\ O_2 y x) -> (A_1 y \/ M_1 y).
Admitted.

(* P31a: L'entendement est un mode *)
(* Prémisses: DP5, A9, D4b, D3, A2, A17a *)
Theorem P31a : forall x:U,
  U_1 x -> M_1 x.
Admitted.

(* P31b: La volonté est un mode *)
(* Prémisses: DP5, A9, D4b, D3, A2, A17b *)
Theorem P31b : forall x:U,
  W_1 x -> M_1 x.
Admitted.

(* P31c: Le désir est un mode *)
(* Prémisses: DP5, A9, D4b, D3, A2, A17c *)
Theorem P31c : forall x:U,
  D_1 x -> M_1 x.
Admitted.

(* P31d: L'amour est un mode *)
(* Prémisses: DP5, A9, D4b, D3, A2, A17d *)
Theorem P31d : forall x:U,
  J_1 x -> M_1 x.
Admitted.

(* P32: La volonté ne peut être appelée cause libre *)
(* Prémisses: P31b, DP6, P14, P29, P16, D7a *)
Theorem P32 : forall x:U,
  W_1 x -> (~B_1 x /\ N_1 x).
Admitted.

(* P33: Les choses n'auraient pu être produites par Dieu d'aucune autre manière *)
(* Note: Jarrett indique que cette proposition n'est pas dérivable de son système formel *)
Theorem P33 : forall x:U,
  exists g:U, G_1 g -> 
  L(forall y:U, K_2 g y -> ~M(exists z:U, z <> y /\ K_2 g z)).
Admitted.

(* P34: La puissance de Dieu est son essence même *)
(* Prémisses: DP7, P14-A, D6, D3, D4b, A19 *)
Theorem P34 : forall x:U,
  exists g:U, G_1 g /\ (A_2 x g <-> P_2 x g).
Admitted.

(* P35: Tout ce qui existe est nécessaire *)
(* Prémisses: identiques à P29 *)
Theorem P35 : exists g:U,
  G_1 g /\ L(exists x:U, x = g) /\ (forall x:U, x <> g -> N_1 x).
Admitted.

(* P36: Il n'existe rien dont la nature ne produise quelque effet *)
(* Note: Jarrett indique que cette proposition n'est pas dérivable de son système formel *)
Theorem P36 : forall x:U,
  (exists v:U, v = x) -> (exists y:U, K_2 x y).
Admitted.

End SpinozaJarrett.